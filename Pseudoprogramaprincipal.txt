//Programa principal.


SolucionDirecta(p, q: indice)
var i, j, n, m : int
var maxi, indicemaxi, indice, contador, repeticion, inicio : int
var anterior : boolean

var A[n] of char
var B[m] of char

contador := 0;
repeticion := 0;
maxi := 0;
anterior := false
i := 0;
indicemax := 0;

mientras i < n hacer
	j := 0
  	mientras (A[i] = B[j]) && (i < n) hacer 
  		i+=1
	  	repeticion := 0
	  	anterior := false
	fin_mientras
	i+=1
	j+=1
	contador+=1
	mientras (contador < m)
		si (A[i] = B[j])
			si (contador = m-1)
				repeticion+=1
				i+=1
				j := 0
				contador := 0
				si (anterior = false) 
					indice = (i + 1) - m
				fin_si
				anterior = true
			sino
				contador+=1
				j+=1
				i+=1
			fin_si
		sino
			contador := m
		fin_si
	fin_mientras

	si (repeticion > maxi)
		maxi := repeticion
		repeticion := 0
		indicemax := indice
	fin_si
fin_mientras
inicio := indicemax

	
	Imprimir("Numero de veces que aparece B es: ", maxi)
	
	si (inicio = 0)
		Imprimir("No hay indice posible")
	sino
		Imprimir("El valor de inicio de la concatenacion mas grande es: ", inicio)
	fin_si


DivideVenceras (p, q: indice)
var k: indice
	si Pequeño (p, q) entonces
		solucion := SolucionDirecta(p, q)
	sino
		k := Dividir(p,q)
		solucion := Combinar(DivideYVencerás(p, k-1), DivideYVencerás(k, q))

//Dividir método.

Dividir(p,q)
	return k := round((q - p)/2)

//Pequeño método:

Pequeño(p, q)
	if q - p <= base
	   return true
	else
	   return false
	   


	
